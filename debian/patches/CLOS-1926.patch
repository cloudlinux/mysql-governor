diff --git a/src/dbtop_server.c b/src/dbtop_server.c
index 46ff041..2fb7b60 100644
--- a/src/dbtop_server.c
+++ b/src/dbtop_server.c
@@ -246,6 +246,30 @@
   return NULL;
 }
 
+/* NOTE:
+   Modifying a GHashTable while iterating over it can lead to undefined behavior.
+   More safe and common approach to mitigate this issue is to create a snapshot of
+   the keys and then iterate over this snapshot to make the necessary modifications.
+ */
+static void
+dbctl_restrict_set_safe(GHashTable *accounts_hash, DbCtlCommand *command)
+{
+    GList *keys, *iterator;
+    gpointer key;
+
+    lock_acc();
+    keys = g_hash_table_get_keys(accounts_hash);
+
+    for (iterator = keys; iterator; iterator = iterator->next)
+    {
+        key = iterator->data;
+        dbctl_restrict_set(key, g_hash_table_lookup(accounts_hash, key), command);
+    }
+
+    unlock_acc();
+    g_list_free(keys);
+}
+
 void *
 run_dbctl_command (void *data)
 {
@@ -278,10 +302,9 @@
 	      close (ns);
 	      return NULL;	//lve use=all or off
 	    }
-	  lock_acc ();
-	  g_hash_table_foreach ((GHashTable *) get_accounts (),
-				(GHFunc) dbctl_restrict_set, &command);
-	  unlock_acc ();
+
+	  GHashTable *accounts = get_accounts();
+	  dbctl_restrict_set_safe(accounts, &command);
 	}
     }
   else if (command.command == UNRESTRICT)
@@ -349,7 +372,8 @@
 	  flag_need_to_renew_dbmap = 1;
   }
 
-  close (ns);
+  if (ns >= 0)
+    close (ns);
 
   return NULL;
 }
diff --git a/src/shared_memory.c b/src/shared_memory.c
index 781c7c0..d6780bc 100644
--- a/src/shared_memory.c
+++ b/src/shared_memory.c
@@ -74,7 +74,7 @@
 } shm_structure;
 
 shm_structure *bad_list = NULL;
-int shm_fd = 0;
+int shm_fd = -1;
 
 int init_bad_users_list_utility(void) {
 
@@ -86,6 +86,7 @@
 			(PROT_READ | PROT_WRITE), MAP_SHARED,
 			shm_fd, 0)) == MAP_FAILED) {
 		close(shm_fd);
+		shm_fd = -1;
 		return -1;
 	}
 
@@ -102,7 +103,12 @@
 	{
 		cl_munmap ((void *) bad_list, sizeof (shm_structure));
 	}
-	close(shm_fd);
+
+	if (shm_fd >= 0)
+	{
+		close(shm_fd);
+		shm_fd = -1;
+	}
 	return 0;
 }
 
@@ -190,7 +196,12 @@
 
 	if (first)
 	{
-		ftruncate(shm_fd, sizeof(shm_structure));
+		if (ftruncate(shm_fd, sizeof(shm_structure)) == -1) {
+			close(shm_fd);
+			shm_fd = -1;
+			umask(old_umask);
+			return -1;
+		}
 	}
 
 	if ((bad_list = (shm_structure *) cl_mmap (0, sizeof (shm_structure),
@@ -198,6 +209,7 @@
 			shm_fd, 0)) == MAP_FAILED)
 	{
 		close(shm_fd);
+		shm_fd = -1;
 		umask(old_umask);
 		return -1;
 	}
@@ -208,6 +220,7 @@
 		{
 			cl_munmap ((void *) bad_list, sizeof (shm_structure));
 			close(shm_fd);
+			shm_fd = -1;
 			umask(old_umask);
 			return -1;
 		}
@@ -243,7 +256,14 @@
 	{
 		cl_munmap ((void *) bad_list, sizeof (shm_structure));
 	}
-	close(shm_fd);
+
+	if (shm_fd >= 0)
+	{
+		close(shm_fd);
+		shm_fd = -1;
+	}
+
+	bad_list = NULL;
 	return 0;
 }
 
@@ -252,7 +272,7 @@
 		return -1;
 	long index;
 	for (index = 0; index < bad_list->numbers; index++) {
-		if (!strncmp(bad_list->items[index].username, username, USERNAMEMAXLEN))
+		if (!strncmp(bad_list->items[index].username, username, USERNAMEMAXLEN - 1))
 			return 1;
 	}
 	return 0;
@@ -262,24 +282,30 @@
 int add_user_to_list(const char *username, int is_all) {
 	if (!bad_list || (bad_list == MAP_FAILED))
 		return -1;
+
+	// First check if the user is already in the list
+	// before any locks and heavy operation on the map
+	if (is_user_in_list(username)) return 0;
+
 	int uid = BAD_LVE;
 	if (lock_read_map() == 0) {
 		uid = get_uid(username);
 		unlock_rdwr_map();
 	}
+
 	if (is_all && uid == BAD_LVE) {
 		uid = 0;
 	}
-	if (!is_user_in_list(username)) {
-		if ((bad_list->numbers + 1) == MAX_ITEMS_IN_TABLE)
-			return -2;
-		if (sem_wait(&bad_list->sem) == 0) {
-			strlcpy(bad_list->items[bad_list->numbers].username, username,
-			USERNAMEMAXLEN);
-			bad_list->items[bad_list->numbers++].uid = uid;
-			sem_post(&bad_list->sem);
-		}
+
+	if ((bad_list->numbers + 1) == MAX_ITEMS_IN_TABLE)
+		return -2;
+
+	if (sem_wait(&bad_list->sem) == 0) {
+		strlcpy(bad_list->items[bad_list->numbers].username, username, USERNAMEMAXLEN);
+		bad_list->items[bad_list->numbers++].uid = uid;
+		sem_post(&bad_list->sem);
 	}
+
 	return 0;
 }
 #endif
@@ -289,7 +315,7 @@
 		return -1;
 	long index;
 	for (index = 0; index < bad_list->numbers; index++) {
-		if (!strncmp(bad_list->items[index].username, username, USERNAMEMAXLEN)) {
+		if (!strncmp(bad_list->items[index].username, username, USERNAMEMAXLEN - 1)) {
 			if (sem_wait(&bad_list->sem) == 0) {
 				if (index == (bad_list->numbers - 1)) {
 					bad_list->numbers--;
@@ -425,6 +451,10 @@
 			} else {
 				if (errno == EAGAIN) {
 					trys++;
+
+					if (trys == 400) {
+						break;
+					}
 				} else {
 					trys = 0;
 				}
@@ -438,7 +468,7 @@
 	return fnd;
 }
 
-int shm_fd_clents_global = 0;
+int shm_fd_clents_global = -1;
 shm_structure *bad_list_clents_global = NULL;
 pthread_mutex_t mtx_shared = PTHREAD_MUTEX_INITIALIZER;
 
@@ -470,6 +500,7 @@
 	if (bad_list_clents_global == MAP_FAILED)
 	{
 		close(shm_fd_clents_global);
+		shm_fd_clents_global = -1;
 		pthread_mutex_unlock(&mtx_shared);
 		umask(old_umask);
 		return -2;
@@ -483,6 +514,7 @@
 			cl_munmap ((void *) bad_list_clents_global, sizeof (shm_structure));
 			bad_list_clents_global = NULL;
 			close(shm_fd_clents_global);
+			shm_fd_clents_global = -1;
 			pthread_mutex_unlock(&mtx_shared);
 			return -2;
 		}
@@ -505,7 +537,13 @@
 	pthread_mutex_lock(&mtx_shared);
 	if (bad_list_clents_global && (bad_list_clents_global != MAP_FAILED))
 		cl_munmap ((void *) bad_list_clents_global, sizeof (shm_structure));
-	close(shm_fd_clents_global);
+
+	if (shm_fd_clents_global >= 0)
+	{
+		close(shm_fd_clents_global);
+		shm_fd_clents_global = -1;
+	}
+
 	pthread_mutex_unlock(&mtx_shared);
 	return 0;
 }
